# Tumbler

**Tumbler** is a high-performance, secure polymorphic networking framework designed for Bun (on the server) and the Browser/Node (on the client). It leverages WebAssembly (WASM) to handle security primitives and state management, ensuring consistent and fast execution across environments.

## ðŸš€ Usage Instructions

### Prerequisites
- [Bun](https://bun.sh) v1.0.0 or higher
- Node.js (for client-side tooling if not using Bun there)

### Installation
Tumbler is a monorepo. To install dependencies for all packages:

```bash
bun install
```

### 1. The Build Process
Tumbler utilizes AssemblyScript to compile client-side security limits into WebAssembly.
Use the CLI to build your project's client WASM:

```bash
# From your project root
bun run tumbler-cli build .
```

This commands compiles `src/client/index.ts` (and its imports) into `build/client.wasm`.

### 2. Server Setup (Bun)
Create a server using `@tumbler/server`.

```typescript
import { TumblerServer } from "@tumbler/server";
import { join } from "path";

const server = new TumblerServer({
    port: 8080,
    wasmPath: join(process.cwd(), "build/client.wasm"), // Path to compiled WASM
    // Optional: Handle static files (like your index.html)
    staticHandler: (req) => new Response("Hello from HTTP!")
});

// Register Event Handlers
server.on("chat:message", (data, session) => {
    console.log(`Received: ${data.text}`);
    // Session object contains secure state
});

await server.listen();
```

### 3. Client Setup (Browser)
Initialize the client using `@tumbler/client`.

```typescript
import { TumblerClient } from "@tumbler/client";

const client = new TumblerClient(
    "/client.wasm",       // URL to serve the .wasm file
    "ws://localhost:8080/ws" // WebSocket Endpoint
);

client.onReady = () => {
    console.log("Secure connection established!");
    client.emit("chat:message", { text: "Hello World" });
};

await client.connect();
```

---

## ðŸ“– Detailed Documentation

### Architecture
Tumbler uses a **Hybrid Architecture**:
- **Server**: Runs on Bun, handling WebSocket connections and coordinating events.
- **Client**: Runs in the browser, but delegates core security logic (token generation, state management) to a **WebAssembly (WASM)** module compiled from AssemblyScript.
- **Protocol**: 
  - **Handshake**: Server sends a seed. Client initializes WASM PRNG.
  - **Events**: Messages are binary packets: `[Type (1b)] [Token (8b)] [Payload (JSON)]`.
  - **Security**: Each message requires a unique, sequential token generated by the WASM module. This prevents simple replay attacks and ensures session integrity.

### Package Structure
- **`packages/tumbler-runtime`**: Core logic and the AssemblyScript template for the client WASM. Contains the PRNG (Xorshift128) and token generation logic.
- **`packages/tumbler-server`**: The server-side library. Manages the WebSocket server (`Bun.serve`), verifies tokens against a server-side WASM instance, and dispatches events.
- **`packages/tumbler-client`**: The browser client library. Loads the WASM, connects to the WebSocket, and wraps `emit` calls with secure tokens.
- **`packages/tumbler-cli`**: Command-line tool mainly used for the `build` command to compile the user's client-side AssemblyScript code.

---

## ðŸ”® Project Plans & Limitations

### Current Limitations
1.  **Crypto Strength**: Currently uses **Xorshift128** for token generation. While fast, it is not cryptographically secure compared to modern standards like X25519 or ChaCha20.
2.  **Encryption**: Payloads are currently JSON-encoded strings inside a binary wrapper. Full encryption of the payload is planned but not fully implemented in the current version.
3.  **Hardcoded Secrets**: The current template uses a placeholder `HARDCODED_SECRET` or a seed exchange. A robust Diffie-Hellman key exchange is planned for future iterations.

### Roadmap
1.  **Full Encryption Tunnel**: Implement *ChaCha20-Poly1305* in WASM to encrypt the entire payload, not just sign it with a token.
2.  **Handshake Protocol Upgrade**: Move to *X25519* based ECDH handshake for shared secret derivation.
3.  **RPC Support**: Add native Request-Response patterns (`client.request('getData')`).
4.  **Binary Serialization**: Replace JSON payload with MessagePack or a custom binary format for improved performance.
